#!/usr/bin/env bash
#
# Copyright 2018 Square Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

set -o errexit  # quit on first error
set -o pipefail # quit on failures in pipes
set -o nounset  # quit on unset variables

[[ ${TRACE:-} ]] && set -o xtrace # output subcommands if TRACE is set

declare -r SUDO_SOCKET_PATH="/var/run/sudo_pair"

pair() {
    declare -r socket="${1}"
    declare -r token="${2}"

    # restore TTY settings on exit
    # shellcheck disable=SC2064
    trap "stty $(stty -g)" EXIT

    # disable line-buffering and local echo, so the pairer doesn't
    # get confused that their typing in the shell isn't doing
    # anything
    stty cbreak -echo

    # send SIGINT on Ctrl-D
    stty intr "^D"

    clear

    # prompt the user to approve
    #
    # The `kill $!` trick warrants some explanation. `$!` evaluates to
    # the `pid` of the most-recent subshell, so this kills the echo/cat
    # subshell when the `socat` has finished. This is necessary because
    # the subshell won't exit automatically when `socat` end of the pipe
    # closes. It only closes when it tries to send more data to the pipe
    # (which causes a SIGPIPE to get sent). So the `kill` ensures the
    # subshell is killed without the user having to type something
    # additional that would cause the command to exit.
    { socat STDIO unix-connect:"${socket}"; kill $!; } < <(
        echo -n "${token}" ; cat -
    )
}

usage() {
    echo "Usage: $(basename -- "$0") pid"
    exit 1
}

main() {
    declare -r socket_path="${1}"
    declare -ri pid="${2}"

    declare -r socket="${socket_path}/${pid}.sock"

    declare -i socket_uid socket_gid socket_mode
    IFS=, read socket_uid socket_gid socket_mode < <(
      stat -c '%u,%g,%a' "${socket}"
    )
    declare -r socket_uid socket_gid socket_mode

    # if we don't have an authentication token from the pipe yet, get
    # one (and export it as an environment variable in case we have to
    # call ourselves again under `sudo`)
    if [[ -z ${SUDO_PAIR_TOKEN:-} ]]; then
        declare -x SUDO_PAIR_TOKEN
        SUDO_PAIR_TOKEN=$(socat unix-connect:"${socket}" STDOUT)
        declare -r SUDO_PAIR_TOKEN
    fi

    # if we can write:          pair
    # if user-owner can write:  sudo to them and try again
    # if group-owner can write: sudo to them and try again
    # if none, die
    if [ -w "${socket}" ]; then
        pair "${socket}" "${SUDO_PAIR_TOKEN}"
    elif [[ $(( 8#${socket_mode} & 8#200 )) -ne 0 ]]; then
        sudo -u \#"${socket_uid}" "${0}" "${pid}"
    elif [[ $(( 8#${socket_mode} & 8#020 )) -ne 0 ]]; then
        sudo -g \#"${socket_gid}" "${0}" "${pid}"
    else
        echo "The socket for this sudo session is neither user- nor group-writable."
        exit 2
    fi
}

case "$#" in
    1) main "${SUDO_SOCKET_PATH}" "$1" ;;
    *) usage ;;
esac
